<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>å¤§æ‰«é™¤</title>
    <style>
        body { font-family: 'Courier New', monospace; background: #c0c0c0; text-align: center; padding-top: 20px; }
        
        /* æ‰«é›·é¢æ¿å¤–æ¡† */
        #game-container {
            display: inline-block;
            background: #bdbdbd;
            border: 3px solid #fff;
            border-right-color: #7b7b7b;
            border-bottom-color: #7b7b7b;
            padding: 10px;
            user-select: none;
        }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #bdbdbd;
            border: 2px solid #7b7b7b;
            border-right-color: #fff;
            border-bottom-color: #fff;
            padding: 5px 10px;
            margin-bottom: 10px;
        }

        .lcd-display {
            background: #000;
            color: #ff0000;
            font-family: 'Courier New', Courier, monospace;
            font-size: 24px;
            font-weight: bold;
            padding: 2px 5px;
            border: 1px solid #7b7b7b;
            min-width: 40px;
        }

        #face {
            width: 30px;
            height: 30px;
            background: #bdbdbd;
            border: 2px solid #fff;
            border-right-color: #7b7b7b;
            border-bottom-color: #7b7b7b;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }

        /* æ¸¸æˆç½‘æ ¼ï¼šä¿®æ”¹ä¸º 20x35ï¼Œæ ¼å­å¤§å°è°ƒä¸º 22px ä»¥é€‚åº”å±å¹• */
        #grid {
            display: grid;
            grid-template-columns: repeat(35, 22px);
            grid-template-rows: repeat(20, 22px);
            border: 2px solid #7b7b7b;
            border-right-color: #fff;
            border-bottom-color: #fff;
        }

        .cell {
            width: 22px;
            height: 22px;
            background: #bdbdbd;
            border: 2px solid #fff;
            border-right-color: #7b7b7b;
            border-bottom-color: #7b7b7b;
            box-sizing: border-box;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px; /* ç¼©å°å­—å·ä»¥é€‚åº”å°æ ¼å­ */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell.revealed {
            border: 1px solid #7b7b7b;
            background: #bdbdbd;
            cursor: default;
        }

        .cell.mine { background-color: #7b7b7b; }
        .cell.mine-hit { background-color: red; }

        /* æ•°å­—é¢œè‰² */
        .n1 { color: blue; } .n2 { color: green; } .n3 { color: red; } 
        .n4 { color: darkblue; } .n5 { color: darkred; } .n6 { color: teal; }
        .n7 { color: black; } .n8 { color: gray; }
    </style>
</head>
<body>

    <h1>ç¬¬å››å…³ï¼šéœ€è¦ç”µè„‘å³é”®</h1>
    <p>å¦åˆ™æ²¡æ³•æ ‡é›·</p >

    <div id="game-container">
        <div id="status-bar">
            <div id="mine-count" class="lcd-display">228</div>
            <div id="face" onclick="location.reload()">ğŸ™‚</div>
            <div id="timer" class="lcd-display">000</div>
        </div>
        <div id="grid"></div>
    </div>

    <script>
        // ä¿®æ”¹ä¸º 20x35 å’Œ 228 é¢—é›·
        const rows = 20;
        const cols = 35;
        const minesCount = 228;
        
        let mines = [];
        let revealedCount = 0;
        let flags = 0;
        let timerInterval = null;
        let timeElapsed = 0;
        let gameOver = false;
        let firstClick = true;

        const gridElement = document.getElementById('grid');
        const mineDisplay = document.getElementById('mine-count');
        const timerDisplay = document.getElementById('timer');
        const face = document.getElementById('face');

        function init() {
            gridElement.innerHTML = '';
            for (let i = 0; i < rows * cols; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.dataset.index = i;
                cell.addEventListener('mousedown', (e) => handleMouse(e, i));
                cell.addEventListener('contextmenu', (e) => e.preventDefault());
                gridElement.appendChild(cell);
            }
            // åˆå§‹åŒ–æ˜¾ç¤º
            mineDisplay.innerText = minesCount.toString().padStart(3, '0');
        }

        function handleMouse(e, index) {
            if (gameOver) return;
            
            // å·¦é”®ç‚¹å‡»
            if (e.button === 0) {
                if (gridElement.children[index].innerText === 'ğŸš©') return;
                
                if (firstClick) {
                    startTimer();
                    generateMines(index);
                    firstClick = false;
                }
                reveal(index);
            } 
            // å³é”®ç‚¹å‡»
            else if (e.button === 2) {
                toggleFlag(index);
            }
        }

        function startTimer() {
            if (timerInterval) return; // é˜²æ­¢é‡å¤å¯åŠ¨
            timerInterval = setInterval(() => {
                timeElapsed++;
                timerDisplay.innerText = Math.min(timeElapsed, 999).toString().padStart(3, '0');
            }, 1000);
        }

        function generateMines(excludeIndex) {
            let positions = Array.from({length: rows * cols}, (_, i) => i);
            positions = positions.filter(p => p !== excludeIndex); 
            positions.sort(() => Math.random() - 0.5);
            mines = positions.slice(0, minesCount);
        }

        function toggleFlag(index) {
            const cell = gridElement.children[index];
            if (cell.classList.contains('revealed')) return;

            if (cell.innerText === 'ğŸš©') {
                cell.innerText = '';
                flags--;
            } else {
                cell.innerText = 'ğŸš©';
                flags++;
            }
            // å®æ—¶æ›´æ–°å‰©ä½™é›·æ•°æ˜¾ç¤º
            mineDisplay.innerText = Math.max(minesCount - flags, -99).toString().padStart(3, '0').slice(-3);
        }

        function reveal(index) {
            const cell = gridElement.children[index];
            if (cell.classList.contains('revealed') || cell.innerText === 'ğŸš©') return;

            if (mines.includes(index)) {
                endGame(false, index);
                return;
            }

            const mCount = countMines(index);
            cell.classList.add('revealed');
            revealedCount++;

            if (mCount > 0) {
                cell.innerText = mCount;
                cell.classList.add('n' + mCount);
            } else {
                getNeighbors(index).forEach(n => reveal(n));
            }

            if (revealedCount === rows * cols - minesCount) {
                endGame(true);
            }
        }

        function endGame(won, hitIndex) {
            gameOver = true;
            clearInterval(timerInterval);
            
            mines.forEach(m => {
                const cell = gridElement.children[m];
                cell.classList.add('revealed');
                cell.classList.add('mine');
                if (cell.innerText !== 'ğŸš©') cell.innerText = 'ğŸ’£';
                if (m === hitIndex) cell.classList.add('mine-hit');
            });

            if (won) {
                face.innerText = 'ğŸ˜';
                setTimeout(() => alert('passwordï¼švos'), 500);
            } else {
                face.innerText = 'ğŸ˜µ';
            }
        }

        function getNeighbors(index) {
            const r = Math.floor(index / cols);
            const c = index % cols;
            let res = [];
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    let nr = r + i, nc = c + j;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        res.push(nr * cols + nc);
                    }
                }
            }
            return res;
        }

        function countMines(index) {
            return getNeighbors(index).filter(n => mines.includes(n)).length;
        }

        init();
    </script>
</body>
</html>
